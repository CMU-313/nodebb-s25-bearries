/// <amd-module name="emoji"/>
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
define("emoji", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.init = exports.strategy = exports.search = exports.table = exports.buildEmoji = exports.buster = exports.base = void 0;
    var base = "".concat(config.assetBaseUrl, "/plugins/nodebb-plugin-emoji");
    exports.base = base;
    var buster = config['cache-buster'];
    exports.buster = buster;
    function buildEmoji(emoji, defer) {
        var whole = ":".concat(emoji.name, ":");
        var deferClass = defer ? ' defer' : '';
        if (emoji.image) {
            return "<img\n      ".concat(defer ? 'data-' : '', "src=\"").concat(base, "/emoji/").concat(emoji.pack, "/").concat(emoji.image, "?").concat(buster, "\"\n      class=\"not-responsive emoji emoji-").concat(emoji.pack, " emoji--").concat(emoji.name, " ").concat(deferClass, "\"\n      title=\"").concat(whole, "\"\n      alt=\"").concat(emoji.character, "\"\n    />");
        }
        return "<span\n    class=\"emoji-".concat(emoji.pack, " emoji--").concat(emoji.name, "\"\n    title=\"").concat(whole, "\"\n  ><span>").concat(emoji.character, "</span></span>");
    }
    exports.buildEmoji = buildEmoji;
    exports.strategy = {
        match: /\B:([^\s\n:]+)$/,
        search: function (term, callback) {
            callback((0, exports.search)(term.toLowerCase().replace(/[_-]/g, '')).slice(0, 10));
        },
        index: 1,
        replace: function (emoji) { return ":".concat(emoji.name, ": "); },
        template: function (emoji) { return "".concat(buildEmoji(emoji), " ").concat(emoji.name); },
        cache: true,
    };
    var initialized;
    function init(callback) {
        var _this = this;
        initialized = initialized || Promise.all([
            new Promise(function (resolve_1, reject_1) { require(['fuzzysearch'], resolve_1, reject_1); }),
            new Promise(function (resolve_2, reject_2) { require(['leven'], resolve_2, reject_2); }),
            new Promise(function (resolve_3, reject_3) { require(['composer/formatting'], resolve_3, reject_3); }),
            $.getJSON("".concat(base, "/emoji/table.json?").concat(buster)),
        ]).then(function (_a) {
            var fuzzy = _a[0], leven = _a[1], formatting = _a[2], tableData = _a[3];
            exports.table = tableData;
            var all = Object.keys(exports.table).map(function (name) {
                var emoji = exports.table[name];
                return {
                    name: name,
                    aliases: emoji.aliases,
                    keywords: emoji.keywords,
                    character: emoji.character,
                    image: emoji.image,
                    pack: emoji.pack,
                };
            });
            function fuzzyFind(term, arr) {
                var l = arr.length;
                for (var i = 0; i < l; i += 1) {
                    if (fuzzy(term, arr[i])) {
                        return arr[i];
                    }
                }
                return null;
            }
            function fuzzySearch(term) {
                function score(match, weight) {
                    var weighted = weight * (1 + leven(term, match));
                    return match.startsWith(term) ? weighted - 2 : weighted;
                }
                return all.filter(function (obj) {
                    if (fuzzy(term, obj.name)) {
                        obj.score = score(obj.name, 1);
                        return true;
                    }
                    var aliasMatch = fuzzyFind(term, obj.aliases);
                    if (aliasMatch) {
                        obj.score = score(aliasMatch, 3);
                        return true;
                    }
                    var keywordMatch = fuzzyFind(term, obj.keywords);
                    if (keywordMatch) {
                        obj.score = score(keywordMatch, 7);
                        return true;
                    }
                    return false;
                }).sort(function (a, b) { return a.score - b.score; }).sort(function (a, b) {
                    var aPrefixed = +a.name.startsWith(term);
                    var bPrefixed = +b.name.startsWith(term);
                    return bPrefixed - aPrefixed;
                });
            }
            exports.search = fuzzySearch;
            formatting.addButtonDispatch('emoji-add-emoji', function (textarea, start, end, event) {
                new Promise(function (resolve_4, reject_4) { require(['emoji-dialog'], resolve_4, reject_4); }).then(function (_a) {
                    var toggleForInsert = _a.toggleForInsert;
                    return toggleForInsert(textarea, start, end, event);
                });
            });
        }).catch(function (err) { return __awaiter(_this, void 0, void 0, function () {
            var e, alerts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        e = Error('[[emoji:meta-load-failed]]');
                        console.error(e);
                        return [4 /*yield*/, app.require('alerts')];
                    case 1:
                        alerts = _a.sent();
                        alerts.error(e);
                        throw err;
                }
            });
        }); });
        if (callback) {
            initialized.then(function () { return setTimeout(callback, 0); });
        }
        return initialized;
    }
    exports.init = init;
});
//# sourceMappingURL=emoji.js.map